#![cfg(test)]

use ark_bls12_381::{Fq, Fq2};
use ark_serialize::CanonicalSerialize;
use core::str::FromStr;
use soroban_sdk::{
    crypto::bls12_381::{Fr, G1Affine, G2Affine, G1_SERIALIZED_SIZE, G2_SERIALIZED_SIZE},
    Env, Vec, U256, Bytes
};

use crate::{Groth16Verifier, Proof, VerificationKey, PublicSignals};

fn g1_from_coords(env: &Env, x: &str, y: &str) -> G1Affine {
    let ark_g1 = ark_bls12_381::G1Affine::new(Fq::from_str(x).unwrap(), Fq::from_str(y).unwrap());
    let mut buf = [0u8; G1_SERIALIZED_SIZE];
    ark_g1.serialize_uncompressed(&mut buf[..]).unwrap();
    G1Affine::from_array(env, &buf)
}

fn g2_from_coords(env: &Env, x1: &str, x2: &str, y1: &str, y2: &str) -> G2Affine {
    let x = Fq2::new(Fq::from_str(x1).unwrap(), Fq::from_str(x2).unwrap());
    let y = Fq2::new(Fq::from_str(y1).unwrap(), Fq::from_str(y2).unwrap());
    let ark_g2 = ark_bls12_381::G2Affine::new(x, y);
    let mut buf = [0u8; G2_SERIALIZED_SIZE];
    ark_g2.serialize_uncompressed(&mut buf[..]).unwrap();
    G2Affine::from_array(env, &buf)
}

#[test]
fn test_with_hardcoded_vk() {
    // Initialize the test environment
    let env = Env::default();

    // Load verification key components (copied from `data/verification_key.json`)
    // These values are pre-computed for the circuit that verifies a*b = c
    // where a=3, b=11, c=33 and only c is public.
    let alphax = "851850525556173310373115880154698084608631105506432893865500290442025919078535925294035153152030470398262539759609";
    let alphay = "2637289349983507610125993281171282870664683328789064436670091381805667870657250691837988574635646688089951719927247";

    let betax1 = "1312620381151154625549413690218290437739613987001512553647554932245743783919690104921577716179019375920325686841943";
    let betax2 = "1853421227732662200477195678252233549930451033531229987959164216695698667330234953033341200627605777603511819497457";
    let betay1 = "3215807833988244618006117550809420301978856703407297742347804415291049013404133666905173282837707341742014140541018";
    let betay2 = "812366606879346135498483310623227330050424196838294715759414425317592599094348477520229174120664109186562798527696";

    let gammax1 = "352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160";
    let gammax2 = "3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758";
    let gammay1 = "1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905";
    let gammay2 = "927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582";

    let deltax1 = "2981843938988033214458466658185878126396080429969635248100956025957789319926032198626745120548947333202362392267114";
    let deltax2 = "2236695112259305382987038341098587500598216646308901956168137697892380899086228863246537938263638056666003066263342";
    let deltay1 = "717163810166643254871951856655865822196000925757284470845197358532703820821048809982340614428800986999944933231635";
    let deltay2 = "3496058064578305387608803828034117220735807855182872031001942587835768203820179263722136810383631418598310938506798";

    let ic0x = "829685638389803071404995253486571779300247099942205634643821309129201420207693030476756893332812706176564514055395";
    let ic0y = "3455508165409829148751617737772894557887792278044850553785496869183933597103951941805834639972489587640583544390358";

    let ic1x = "2645559270376031734407122278942646687260452979296081924477586893972449945444985371392950465676350735694002713633589";
    let ic1y = "2241039659097418315097403108596818813895651201896886552939297756980670248638746432560267634304593609165964274111037";

    // Construct the verification key from the pre-computed components
    let vk = VerificationKey {
        alpha: g1_from_coords(&env, alphax, alphay),
        beta: g2_from_coords(&env, betax1, betax2, betay1, betay2),
        gamma: g2_from_coords(&env, gammax1, gammax2, gammay1, gammay2),
        delta: g2_from_coords(&env, deltax1, deltax2, deltay1, deltay2),
        ic: Vec::from_array(
            &env,
            [
                g1_from_coords(&env, ic0x, ic0y),
                g1_from_coords(&env, ic1x, ic1y),
            ],
        ),
    };

    // Load proof components (copied from `data/proof.json`)
    let pi_ax = "314442236668110257304682488877371582255161413673331360366570443799415414639292047869143313601702131653514009114222";
    let pi_ay = "2384632327855835824635705027009217874826122107057894594162233214798350178691568018290025994699762298534539543934607";
    let pi_bx1 = "428844167033934720609657613212495751617651348480870890908850335525890280786532876634895457032623422366474694342656";
    let pi_bx2 = "3083139526360252775789959298805261067575555607578161553873977966165446991459924053189383038704105379290158793353905";
    let pi_by1 = "1590919422794657666432683000821892403620510405626533455397042191265963587891653562867091397248216891852168698286910";
    let pi_by2 = "3617931039814164588401589536353142503544155307022467123698224064329647390280346725086550997337076315487486714327146";
    let pi_cx = "3052934797502613468327963344215392478880720823583493172692775426011388142569325036386650708808320216973179639719187";
    let pi_cy = "2028185281516938724429867827057869371578022471499780916652824405212207527699373814371051328341613972789943854539597";

    // Construct the proof from the pre-computed components
    let proof = Proof {
        a: g1_from_coords(&env, &pi_ax, &pi_ay),
        b: g2_from_coords(&env, &pi_bx1, &pi_bx2, &pi_by1, &pi_by2),
        c: g1_from_coords(&env, &pi_cx, &pi_cy),
    };

    // Test Case 1: Verify the proof with the correct public output (33, copied from `data/public.json`)
    let output = Vec::from_array(&env, [Fr::from_u256(U256::from_u32(&env, 33))]);
    let res = Groth16Verifier::verify_proof(&env, vk.clone(), proof.clone(), &output).unwrap();
    assert_eq!(res, true);

    // Print out the budget report showing CPU and memory cost breakdown for
    // different operations (zero-value operations omitted for brevity)
    env.cost_estimate().budget().print();
    /*
    =================================================================
    Cpu limit: 100000000; used: 40968821
    Mem limit: 41943040; used: 297494
    =================================================================
    CostType                           cpu_insns      mem_bytes
    MemAlloc                           12089          3401
    MemCpy                             3091           0
    MemCmp                             928            0
    VisitObject                        5917           0
    ComputeSha256Hash                  3738           0
    Bls12381EncodeFp                   2644           0
    Bls12381DecodeFp                   29550          0
    Bls12381G1CheckPointOnCurve        13538          0
    Bls12381G1CheckPointInSubgroup     3652550        0
    Bls12381G2CheckPointOnCurve        23684          0
    Bls12381G2CheckPointInSubgroup     4231288        0
    Bls12381G1ProjectiveToAffine       185284         0
    Bls12381G1Add                      7689           0
    Bls12381G1Mul                      2458985        0
    Bls12381Pairing                    30335852       294093
    Bls12381FrFromU256                 1994           0
    // ... zero-value rows omitted ...
    =================================================================
    */

    // Test Case 2: Verify the proof with an incorrect public output (22)
    let output = Vec::from_array(&env, [Fr::from_u256(U256::from_u32(&env, 22))]);
    let res = Groth16Verifier::verify_proof(&env, vk, proof, &output).unwrap();
    assert_eq!(res, false);
}

#[test]
fn test_with_circom2soroban_output() {
    let env = Env::default();

    let alphax = "3747424941603402268361699745001854633014744937273750680241086531929563811053644994104663362172135397158933644732769";
    let alphay = "3988270719613075850599363358389871346508135461410965432812272991775727534181494682456780460875277721404051889718365";
    let betax1 = "1524697016042884165313306760188648321951005417956121512876963277584907694454409573781160610530537485279864685673476";
    let betax2 = "412991159702677602477943588110116178996282791294527953176916401488419471086841528515891441472334815486249056797338";
    let betay1 = "3916121343675848239958862389733312831623003692196409224010750692694641149859846091758947486087378597010991240658177";
    let betay2 = "3414240119772657921827165873165712163213689442255818817262020650338672456890199595260427614694802487144556998749052";
    let gammax1 = "352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160";
    let gammax2 = "3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758";
    let gammay1 = "1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905";
    let gammay2 = "927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582";
    let deltax1 = "352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160";
    let deltax2 = "3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758";
    let deltay1 = "1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905";
    let deltay2 = "927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582";
    let ic0x = "474952218074335863578664511024945165344669103923167332389103736276210593389972064509878520740161937977997054054001";
    let ic0y = "603113250469777993716180248063826731461277231763492855005256665015412916162238075305366716623156236156854946844790";
    let ic1x = "2856604914760717213286948932893423171459919318753357293811398930302237923886719800243791210923391190741419079860011";
    let ic1y = "3860559014590268839847636251095308099241297494019641587854667966109705297682849364509800320911445835318007004527450";

    // Construct the verification key from the pre-computed components
    let vk = VerificationKey {
        alpha: g1_from_coords(&env, alphax, alphay),
        beta: g2_from_coords(&env, betax1, betax2, betay1, betay2),
        gamma: g2_from_coords(&env, gammax1, gammax2, gammay1, gammay2),
        delta: g2_from_coords(&env, deltax1, deltax2, deltay1, deltay2),
        ic: Vec::from_array(
            &env,
            [
                g1_from_coords(&env, ic0x, ic0y),
                g1_from_coords(&env, ic1x, ic1y),
            ],
        ),
    };
    
    // Load proof components (copied from `data/proof.json`)
    let pi_ax = "314442236668110257304682488877371582255161413673331360366570443799415414639292047869143313601702131653514009114222";
    let pi_ay = "2384632327855835824635705027009217874826122107057894594162233214798350178691568018290025994699762298534539543934607";
    let pi_bx1 = "428844167033934720609657613212495751617651348480870890908850335525890280786532876634895457032623422366474694342656";
    let pi_bx2 = "3083139526360252775789959298805261067575555607578161553873977966165446991459924053189383038704105379290158793353905";
    let pi_by1 = "1590919422794657666432683000821892403620510405626533455397042191265963587891653562867091397248216891852168698286910";
    let pi_by2 = "3617931039814164588401589536353142503544155307022467123698224064329647390280346725086550997337076315487486714327146";
    let pi_cx = "3052934797502613468327963344215392478880720823583493172692775426011388142569325036386650708808320216973179639719187";
    let pi_cy = "2028185281516938724429867827057869371578022471499780916652824405212207527699373814371051328341613972789943854539597";

    // Construct the proof from the pre-computed components
    let proof = Proof {
        a: g1_from_coords(&env, &pi_ax, &pi_ay),
        b: g2_from_coords(&env, &pi_bx1, &pi_bx2, &pi_by1, &pi_by2),
        c: g1_from_coords(&env, &pi_cx, &pi_cy),
    };

    let res = Groth16Verifier::verify_proof(&env, vk, proof, &Vec::from_array(&env, [Fr::from_u256(U256::from_u32(&env, 0))])).unwrap();
    assert_eq!(res, false); // Should be false for dummy proof/key
}

#[test]
fn test_coin_ownership() {
    let env = Env::default();

    let alphax = "2625583050305146829700663917277485398332586266229739236073977691599912239208704058548731458555934906273399977862822";
    let alphay = "1155364156944807367912876641032696519500054551629402873339575774959620483194368919563799050765095981406853619398751";
    
    
    let betax1 = "1659696755509039809248937927616726274238080235224171061036366585278216098417245587200210264410333778948851576160490";
    let betax2 = "1338363397031837211155983756179787835339490797745307535810204658838394402900152502268197396587061400659003281046656";
    let betay1 = "1974652615426136516341494326987376616840373177388374023461177997087381634383568759591087499459321812809521924259354";
    let betay2 = "3301884318087924474550898163462840036865878131635519297186391370517333773367262804074867347346141727012544462046142";
    
    
    let gammax1 = "352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160";
    let gammax2 = "3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758";
    let gammay1 = "1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905";
    let gammay2 = "927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582";
    
    
    let deltax1 = "2743142984898738125001654242270255897674294587748253980774444623218527122281885484824857579589713606363239065733017";
    let deltax2 = "204094511116361675952446773023082620129915086661714657422228091029815576847171516978148871266279683009739984647370";
    let deltay1 = "1939174617523090044587198902486590913714778055316589513843553175656942451344239147573490910682365706772067255113505";
    let deltay2 = "2292766382025993571077921250915535065222739994205317155933298500829977470451722231881154853465745409220984289503104";
    
    
    let ic0x = "2683618448904306335228903505299721458337998659387683182703607938866093851528642837054373953710816742402346993120797";
    let ic0y = "1786668422239574992109894972831696712754414376375650177546698505846675773736122594055286256880476355557498422341634";
    
    
    let ic1x = "66902808652025389632864246790882182391974469705330059940923330385191291897071317426471178445902460845068967727278";
    let ic1y = "2594765160054401352409621725597484660493244453849646390863879503499356393964853319062162092260143573762198575717487";
    
    let ic2x = "1003382246631454829876446584401033316871748572555275360455886052458082997944181369047339077877767811660479191253501";
    let ic2y = "2544403050708001388892167906290198493026544815081144389732529981844829005748116399510257129962201796703233322017126";

    let vk = VerificationKey {
        alpha: g1_from_coords(&env, alphax, alphay),
        beta: g2_from_coords(&env, betax1, betax2, betay1, betay2),
        gamma: g2_from_coords(&env, gammax1, gammax2, gammay1, gammay2),
        delta: g2_from_coords(&env, deltax1, deltax2, deltay1, deltay2),
        ic: Vec::from_array(
            &env,
            [
                g1_from_coords(&env, ic0x, ic0y),
                g1_from_coords(&env, ic1x, ic1y),
                g1_from_coords(&env, ic2x, ic2y),
            ],
        ),
    };

    let pi_ax = "2312845116701672402180486748482758387792019392638873512193039748796932219258491169543785273216043839153656695561028";
    let pi_ay = "2401388344361274103911290492305041495151045197799709253975549979749000050189613887123319051631926316639875318530706";


    let pi_bx1 = "254112989406552222064547883149713450818858945843832143975529650914462737635290229325433889900886989167652287651477";
    let pi_bx2 = "1298427328165001466050889647718980726801340148316849424955517639658980366356339914458078849522724674106484718321177";
    let pi_by1 = "5321429806065285653141424032098896697927422746457669045090054322756670504823633361000243836633074177798333017419";
    let pi_by2 = "2189884843665900970576104345488554859679199450652275441615353017043226667793893188654509510191387551155638147549016";


    let pi_cx = "2191481390831460536193287377108883221181604287496545032823796584973842680176886739387559733959993660004385853733594";
    let pi_cy = "423577060414004702507038675020769607957163072861493245791725852305440453270407094427666302510671441390869114232609";

    let proof = Proof {
        a: g1_from_coords(&env, &pi_ax, &pi_ay),
        b: g2_from_coords(&env, &pi_bx1, &pi_bx2, &pi_by1, &pi_by2),
        c: g1_from_coords(&env, &pi_cx, &pi_cy),
    };

    // Public output signals:
    let public_0 = U256::from_be_bytes(&env, &Bytes::from_array(&env, &[0x07, 0xf5, 0x2b, 0x5b, 0x26, 0x8b, 0xf6, 0x29, 0xbc, 0x53, 0x78, 0x3e, 0xfa, 0xf4, 0xa8, 0x20, 0x36, 0xaa, 0x76, 0xf2, 0xa5, 0x57, 0x04, 0x4f, 0xfe, 0xf6, 0x7e, 0x92, 0xf2, 0x60, 0xf6, 0xf8]));
    let public_1 = U256::from_be_bytes(&env, &Bytes::from_array(&env, &[0x00, 0x09, 0x7b, 0xa5, 0x84, 0xee, 0xbc, 0x88, 0x32, 0xb6, 0x7d, 0x9d, 0x89, 0xd9, 0xd2, 0xd7, 0x12, 0xfb, 0x44, 0xe0, 0x53, 0xa3, 0x0e, 0x9d, 0x1a, 0x61, 0x64, 0xcd, 0x6b, 0x33, 0xc5, 0xde]));

    // Create output vector for verification:
    let output = Vec::from_array(&env, [Fr::from_u256(public_0), Fr::from_u256(public_1)]);
    
    let res = Groth16Verifier::verify_proof(&env, vk, proof, &output).unwrap();
    assert_eq!(res, true);
}

#[test]
fn test_vk_serde() {
    let env = Env::default();

    let alphax = "3747424941603402268361699745001854633014744937273750680241086531929563811053644994104663362172135397158933644732769";
    let alphay = "3988270719613075850599363358389871346508135461410965432812272991775727534181494682456780460875277721404051889718365";
    let betax1 = "1524697016042884165313306760188648321951005417956121512876963277584907694454409573781160610530537485279864685673476";
    let betax2 = "412991159702677602477943588110116178996282791294527953176916401488419471086841528515891441472334815486249056797338";
    let betay1 = "3916121343675848239958862389733312831623003692196409224010750692694641149859846091758947486087378597010991240658177";
    let betay2 = "3414240119772657921827165873165712163213689442255818817262020650338672456890199595260427614694802487144556998749052";
    let gammax1 = "352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160";
    let gammax2 = "3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758";
    let gammay1 = "1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905";
    let gammay2 = "927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582";
    let deltax1 = "352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160";
    let deltax2 = "3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758";
    let deltay1 = "1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905";
    let deltay2 = "927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582";
    let ic0x = "474952218074335863578664511024945165344669103923167332389103736276210593389972064509878520740161937977997054054001";
    let ic0y = "603113250469777993716180248063826731461277231763492855005256665015412916162238075305366716623156236156854946844790";
    let ic1x = "2856604914760717213286948932893423171459919318753357293811398930302237923886719800243791210923391190741419079860011";
    let ic1y = "3860559014590268839847636251095308099241297494019641587854667966109705297682849364509800320911445835318007004527450";

    // Construct the verification key from the pre-computed components
    let vk = VerificationKey {
        alpha: g1_from_coords(&env, alphax, alphay),
        beta: g2_from_coords(&env, betax1, betax2, betay1, betay2),
        gamma: g2_from_coords(&env, gammax1, gammax2, gammay1, gammay2),
        delta: g2_from_coords(&env, deltax1, deltax2, deltay1, deltay2),
        ic: Vec::from_array(
            &env,
            [
                g1_from_coords(&env, ic0x, ic0y),
                g1_from_coords(&env, ic1x, ic1y),
            ],
        ),
    };

    let vk_bytes = vk.to_bytes(&env);
    let deserialized_vk = VerificationKey::from_bytes(&env, &vk_bytes).unwrap();

    assert_eq!(vk.alpha, deserialized_vk.alpha);
    assert_eq!(vk.beta, deserialized_vk.beta);
    assert_eq!(vk.gamma, deserialized_vk.gamma);
    assert_eq!(vk.delta, deserialized_vk.delta);
    assert_eq!(vk.ic, deserialized_vk.ic);
}

#[test]
fn test_proof_serde() {
    let env = Env::default();

    let pi_ax = "2312845116701672402180486748482758387792019392638873512193039748796932219258491169543785273216043839153656695561028";
    let pi_ay = "2401388344361274103911290492305041495151045197799709253975549979749000050189613887123319051631926316639875318530706";


    let pi_bx1 = "254112989406552222064547883149713450818858945843832143975529650914462737635290229325433889900886989167652287651477";
    let pi_bx2 = "1298427328165001466050889647718980726801340148316849424955517639658980366356339914458078849522724674106484718321177";
    let pi_by1 = "5321429806065285653141424032098896697927422746457669045090054322756670504823633361000243836633074177798333017419";
    let pi_by2 = "2189884843665900970576104345488554859679199450652275441615353017043226667793893188654509510191387551155638147549016";


    let pi_cx = "2191481390831460536193287377108883221181604287496545032823796584973842680176886739387559733959993660004385853733594";
    let pi_cy = "423577060414004702507038675020769607957163072861493245791725852305440453270407094427666302510671441390869114232609";

    let proof = Proof {
        a: g1_from_coords(&env, &pi_ax, &pi_ay),
        b: g2_from_coords(&env, &pi_bx1, &pi_bx2, &pi_by1, &pi_by2),
        c: g1_from_coords(&env, &pi_cx, &pi_cy),
    };

    let proof_bytes = proof.to_bytes(&env);
    let deserialized_proof = Proof::from_bytes(&env, &proof_bytes);

    assert_eq!(proof.a, deserialized_proof.a);
    assert_eq!(proof.b, deserialized_proof.b);
    assert_eq!(proof.c, deserialized_proof.c);
}

#[test]
fn test_public_signals_serde() {
    let env = Env::default();

    let pub_signals = PublicSignals {
        pub_signals: Vec::from_array(&env, [Fr::from_u256(U256::from_u32(&env, 33))])
    };

    let pub_signals_bytes = pub_signals.to_bytes(&env);
    let deserialized_pub_signals = PublicSignals::from_bytes(&env, &pub_signals_bytes);
    
    assert_eq!(pub_signals.pub_signals, deserialized_pub_signals.pub_signals);
}